Directory structure of .:
.
├── Arch
│   ├── arm
│   │   ├── stage1
│   │   ├── stage2
│   │   └── stage3
│   └── x86
│       ├── stage1(seed)
│       │   ├── gpt.s
│       │   ├── mbr.s
│       │   └── seed.s
│       ├── stage2(pit)
│       └── stage3(flesh)
│           └── f
├── README.md
├── assets
│   ├── full_tree.log
│   ├── mascot
│   │   ├── mascot.jpg
│   │   ├── mascot.png
│   │   ├── mascot.svg
│   │   └── mascot_ascii.txt
│   └── tree.log
├── common
│   ├── stage1
│   ├── stage2
│   └── stage3
├── tree_20241218_170605.log
└── uefi

18 directories, 11 files

Contents of human-readable files:

--- File: ./Arch/x86/stage1(seed)/gpt.s ---
; gpt.s - Detects GPT on a disk using BIOS interrupts
; This is Stage 1 of the bootloader (seed.s) for x86 architecture.

BITS 16                 ; Real mode, 16-bit code
ORG 0x7C00              ; BIOS loads the bootloader here

start:
    cli                 ; Clear interrupts
    xor ax, ax          ; Zero out AX
    mov ds, ax          ; Set data segment to 0
    mov es, ax          ; Set extra segment to 0

    ; Display a message indicating we're detecting GPT
    mov si, gpt_msg
    call print_string

    ; Read GPT Header from LBA 1 (sector 1)
    mov ah, 0x02        ; BIOS interrupt: Read sectors
    mov al, 1           ; Read 1 sector
    mov ch, 0           ; Cylinder 0
    mov cl, 2           ; Sector 2 (LBA 1)
    mov dh, 0           ; Head 0
    mov dl, 0x80        ; Disk 0 (First hard disk)
    mov bx, 0x600       ; Load GPT Header to 0x0600:0000
    int 0x13            ; BIOS interrupt to read disk

    jc disk_error       ; If carry flag is set, there's an error reading

    ; Check GPT signature at the beginning of the GPT Header
    mov si, 0x600       ; Point to the GPT Header (memory location)
    mov di, gpt_sig     ; The "EFI PART" signature
    mov cx, 8           ; GPT signature length
    repe cmpsb          ; Compare the bytes of the signature
    jz is_gpt           ; If the signature matches, it's GPT

    ; If signature does not match, display error
    jmp not_gpt_error

is_gpt:
    ; GPT detected, proceed to load partition entries or Stage 2
    mov si, gpt_found_msg
    call print_string
    ; Proceed to Stage 2 (loading partition entry array)...
    jmp continue_boot

not_gpt_error:
    ; Not a GPT disk, handle the error
    mov si, not_gpt_msg
    call print_string
    jmp disk_error

disk_error:
    mov si, error_msg
    call print_string
    hlt                   ; Halt the CPU

print_string:
    ; Print a null-terminated string pointed to by SI
    mov ah, 0x0E          ; Teletype output function
.print_char:
    lodsb                 ; Load next byte from [SI] into AL
    or al, al             ; Check if it's null (end of string)
    jz .done              ; If null, end of string
    int 0x10              ; BIOS interrupt to print character
    jmp .print_char
.done:
    ret

gpt_msg db "Detecting GPT...", 0
gpt_sig db "EFI PART", 0       ; GPT Header signature
gpt_found_msg db "GPT Disk Found.", 0
not_gpt_msg db "Not a GPT disk!", 0
error_msg db "Disk read error!", 0

times 510-($-$$) db 0  ; Pad with zeroes to 510 bytes
dw 0xAA55             ; Boot signature

--- File: ./Arch/x86/stage1(seed)/mbr.s ---
; mbr.s - Detects MBR on a disk using BIOS interrupts
; This is Stage 1 of the bootloader (seed.s) for x86 architecture.

BITS 16                 ; Real mode, 16-bit code
ORG 0x7C00              ; BIOS loads the bootloader here

start:
    cli                 ; Clear interrupts
    xor ax, ax          ; Zero out AX
    mov ds, ax          ; Set data segment to 0
    mov es, ax          ; Set extra segment to 0

    ; Display a message indicating we're detecting MBR
    mov si, mbr_msg
    call print_string

    ; Read MBR (first sector, LBA 0)
    mov ah, 0x02        ; BIOS interrupt: Read sectors
    mov al, 1           ; Read 1 sector
    mov ch, 0           ; Cylinder 0
    mov cl, 1           ; Sector 1 (LBA 0)
    mov dh, 0           ; Head 0
    mov dl, 0x80        ; Disk 0 (First hard disk)
    mov bx, 0x600       ; Load MBR to 0x0600:0000
    int 0x13            ; BIOS interrupt to read disk

    jc disk_error       ; If carry flag is set, there's an error reading

    ; Check MBR boot signature (last two bytes: 0xAA55)
    mov si, 0x600       ; Point to the MBR (memory location)
    add si, 510         ; Move to the last 2 bytes
    mov ax, [si]        ; Load the 2-byte signature into AX
    cmp ax, 0xAA55      ; Check for the boot signature
    je is_mbr           ; If signature matches, it's MBR

    ; If signature does not match, display error
    jmp not_mbr_error

is_mbr:
    ; MBR detected, proceed to load partition entries or Stage 2
    mov si, mbr_found_msg
    call print_string
    ; Proceed to Stage 2 (loading partition entry table)...
    jmp continue_boot

not_mbr_error:
    ; Not a valid MBR disk, handle the error
    mov si, not

--- File: ./Arch/x86/stage1(seed)/seed.s ---
; seed.s - Detects GPT or MBR on a disk and proceeds to Stage 2 (pit)
; This is Stage 1 of the bootloader for x86 architecture.

BITS 16                 ; Real mode, 16-bit code
ORG 0x7C00              ; BIOS loads the bootloader here

start:
    cli                 ; Clear interrupts
    xor ax, ax          ; Zero out AX
    mov ds, ax          ; Set data segment to 0
    mov es, ax          ; Set extra segment to 0

    ; Display a message indicating we're detecting partition table (GPT/MBR)
    mov si, detect_msg
    call print_string

    ; Try reading GPT first (LBA 1, sector 1)
    mov ah, 0x02        ; BIOS interrupt: Read sectors
    mov al, 1           ; Read 1 sector
    mov ch, 0           ; Cylinder 0
    mov cl, 2           ; Sector 2 (LBA 1)
    mov dh, 0           ; Head 0
    mov dl, 0x80        ; Disk 0 (First hard disk)
    mov bx, 0x600       ; Load GPT Header to 0x0600:0000
    int 0x13            ; BIOS interrupt to read disk

    jc mbr_detect       ; If carry flag is set, there's an error reading, try MBR

    ; Check GPT signature (EFI PART)
    mov si, 0x600       ; Point to the GPT Header (memory location)
    mov di, gpt_sig     ; The "EFI PART" signature
    mov cx, 8           ; GPT signature length
    repe cmpsb          ; Compare the bytes of the signature
    jz is_gpt           ; If the signature matches, it's GPT

mbr_detect:
    ; If we reach here, GPT was not detected. Try MBR (LBA 0, sector 0)
    mov ah, 0x02        ; BIOS interrupt: Read sectors
    mov al, 1           ; Read 1 sector
    mov ch, 0           ; Cylinder 0
    mov cl, 1           ; Sector 1 (LBA 0)
    mov dh, 0           ; Head 0
    mov dl, 0x80        ; Disk 0 (First hard disk)
    mov bx, 0x600       ; Load MBR to 0x0600:0000
    int 0x13            ; BIOS interrupt to read disk

    jc disk_error       ; If carry flag is set, there's an error reading

    ; Check MBR boot signature (last two bytes: 0xAA55)
    mov si, 0x600       ; Point to the MBR (memory location)
    add si, 510         ; Move to the last 2 bytes
    mov ax, [si]        ; Load the 2-byte signature into AX
    cmp ax, 0xAA55      ; Check for the boot signature
    je is_mbr           ; If signature matches, it's MBR

    ; If neither GPT nor MBR is detected, display error
    jmp not_partition_error

is_gpt:
    ; GPT detected, proceed to Stage 2 (pit) for GPT
    mov si, gpt_found_msg
    call print_string
    ; Proceed to Stage 2 (processing GPT partitions)...
    jmp continue_boot

is_mbr:
    ; MBR detected, proceed to Stage 2 (pit) for MBR
    mov si, mbr_found_msg
    call print_string
    ; Proceed to Stage 2 (processing MBR partitions)...
    jmp continue_boot

not_partition_error:
    ; Neither GPT nor MBR detected, handle the error
    mov si, not_partition_msg
    call print_string
    jmp disk_error

disk_error:
    mov si, error_msg
    call print_string
    hlt                   ; Halt the CPU

continue_boot:
    ; Placeholder: Jump to Stage 2 (pit), handling partition entries and kernel loading
    ; This would involve loading the kernel based on partition entries.
    ; Here, we'll just loop for now.
    jmp continue_boot

print_string:
    ; Print a null-terminated string pointed to by SI
    mov ah, 0x0E          ; Teletype output function
.print_char:
    lodsb                 ; Load next byte from [SI] into AL
    or al, al             ; Check if it's null (end of string)
    jz .done              ; If null, end of string
    int 0x10              ; BIOS interrupt to print character
    jmp .print_char
.done:
    ret

; Messages
detect_msg db "Detecting GPT or MBR...", 0
gpt_sig db "EFI PART", 0       ; GPT Header signature
gpt_found_msg db "GPT Disk Found.", 0
mbr_found_msg db "MBR Disk Found.", 0
not_partition_msg db "No valid partition table found!", 0
error_msg db "Disk read error!", 0

times 510-($-$$) db 0  ; Pad with zeroes to 510 bytes
dw 0xAA55             ; Boot signature (MBR signature)

--- File: ./assets/full_tree.log ---
.
├── Arch
│   ├── arm
│   │   ├── stage1
│   │   │   └── .gitkeep
│   │   ├── stage2
│   │   │   └── .gitkeep
│   │   └── stage3
│   │       └── .gitkeep
│   └── x86
│       ├── stage1(seed)
│       │   └── seed.s
│       ├── stage2(pit)
│       │   └── .gitkeep
│       └── stage3(flesh)
│           ├── .gitkeep
│           └── f
├── README.md
├── assets
│   ├── full_tree.log
│   ├── mascot.jpg
│   ├── mascot.png
│   ├── mascot.svg
│   ├── mascot_ascii.txt
│   └── tree.log
├── common
│   ├── stage1
│   │   └── .gitkeep
│   ├── stage2
│   │   └── .gitkeep
│   └── stage3
│       └── .gitkeep
└── uefi
    └── .gitkeep

56 directories, 71 files

--- File: ./assets/mascot/mascot_ascii.txt ---






                                                 o00xxxxx0;
                                             .Odc::::::::::lx
                                           ldc:::::::::::::::cl
                                         dd::::::::::::::::::::o
                                       ld::::::::::clooolc::::::c
                                     'd::::::::ldkO0KKKKK0ko:::::c
                                    x;::::::cdOKKKKKKKKKKKKKOc::::;
                                  ;l::::::oONWWWNXKKKKKKKKKKK0c:::c
                                 d::::::oOKMMMMMMMXKKKKXWWWWNXO::::;
                               .l:::::cxKKKWMN:lMWKKKKXMWWMMMWKo::::
                              xc:::::d0KKKKKNXodNKKKKKXN;;WMMNK0::::;
                            'l:::::oOKKKKKKKKKKKKKKKKKKKXNNNXKKKl:::;
                           x::::::xKKKKK0od0KKKKKKKKKKKKKKKKKKKKx::::.
                         :c:::::lOKKKKKKKKxookKKKKKKKK0xddd0KKKKO::::'
                        o::::::o0KKKKKKKKKKK0ddddddddddx0KKKKKKK0::::'
                       o::::::dKKKKKKKKKKKKKKKKK0OO0KKKKKKKKKKKKK::::;
                      o::::::dKKKKKKKKKKkdolcccclooxOKKKKKKKKKKKK:::::
                     :::::::oKKKKKKKKOo:;,,,,,,,,,,,;cd0KKKKKKKKKc::::.
                    .:::::::0KKKKKK0o;,,,,,,,,,,,,,,,,,;dKKKKKKKKc::::.
                    ;::::::dKKKKKK0c,,,,,,,,,,,,,,,,,,,,,l0KKKKKKc::::,
                    :::::::OKKKKKKc,,,,,,,,,,,,,,,,,,,,,,,oKKKKKK:::::,
                   .:::::::0KKKKKO,,,,,,,,,,,,,,,,,,,,,,,,;0KKKKK:::::.
                    :::::::OKKKKKx,,,,,,,,,,,,,,,,,,,,,,,,,OKKKK0:::::.
                    ;::::::dKKKKKO,,,,,,,,,,,,,,,,,,,,,,,,;0KKKKO:::::.
                    .:::::::OKKKKKl,,,,,,,,,,,,,,,,,,,,,,,oKKKKKx:::::.
                     ,::::::cOKKKK0c,,,,,,,,,,,,,,,,,,,,,lKKKKKO::::::.
                      :::::::ckKKKKKd;,,,,,,,,,,,,,,,,,:xKKKKKk:::::::
                       ':::::::oOKKKK0xl:;,,,,,,,,,;cox0KKKKko:::::::
                        .::::::::okKKKKKKOkxdooddxkOKKKKK0kl::::::::
                          ,::::::::lx0KKKKKKKKKKKKKKKK0kdc::::::::'
                            ;:::::::::ldkO0KKKKKK0Okxoc:::::::::;
                              ;:::::::::::ccllllc:::::::::::::,
                                .::::::::::::::::::::::::::;
                                    ':::::::::::::::::::
                                           .'''..










--- File: ./assets/tree.log ---
.
├── Arch
│   ├── arm
│   │   ├── stage1
│   │   ├── stage2
│   │   └── stage3
│   └── x86
│       ├── stage1(seed)
│       │   └── seed.s
│       ├── stage2(pit)
│       └── stage3(flesh)
│           └── f
├── README.md
├── assets
│   ├── full_tree.log
│   ├── mascot
│   │   ├── mascot.jpg
│   │   ├── mascot.png
│   │   ├── mascot.svg
│   │   └── mascot_ascii.txt
│   └── tree.log
├── common
│   ├── stage1
│   ├── stage2
│   └── stage3
└── uefi

18 directories, 8 files

--- File: ./README.md ---
# Avocado Bootloader

![Avocado Mascot](./assets/mascot/mascot.svg)  
*The multi-stage, multi-boot bootloader with UEFI support!*

## Overview

Avocado is a avocado-themed, multi-stage, multiboot-compliant bootloader designed to support UEFI systems. Inspired by the modularity and flexibility of modern operating systems, Avocado provides a robust foundation for loading kernels efficiently and reliably.

---

## Features

- **Multiboot Compliant**  
  Fully adheres to the multiboot standard for seamless kernel loading.  

- **UEFI Support**  
  Built for modern systems with native UEFI boot capabilities.  

- **Multi-Stage Boot Process**  
  A clean and efficient three-stage design:
  1. **Seed**: Initialization and basic hardware setup.
  2. **Flesh**: Loading the configuration and environment setup.
  3. **Pit**: Launching the operating system kernel.

- **Multi-Architecture Support**  
  Designed to work on multiple architectures, including x86 and ARM.  

- **Customizable**  
  Easily tailored for various operating systems.  

- **Taco-Themed Fun**  
  Why be boring when you can be delicious?

---

## Project Structure
```plaitext
.
├── Arch
│   ├── arm
│   │   ├── stage1
│   │   ├── stage2
│   │   └── stage3
│   └── x86
│       ├── stage1
│       ├── stage2
│       └── stage3
├── README.md
├── assets
│   ├── mascot.svg
│   └── tree.log
├── common
│   ├── stage1
│   ├── stage2
│   └── stage3
└── uefi

16 directories, 3 files



```